---
layout: post
title:  "Notes on The Go Programming Language"
date:   2019-02-16 22:00:00 +0800
categories: golang
---
這本書是2017年去天津出差時在書局看到便宜的英文版就帶回來了, 紙質當然比不上Pearson的版本, 不過內容一樣就不用計較這些了.

工欲善其事, 必先利其器. 要學習golang, 首先要裝好go tool和好用的vim plugin "vim-go".

#### Installing go tool
在golang[官網](https://golang.org/dl/)下載後解壓至/usr/local就完成了.
```bash
sudo tar -C /usr/local -xzf go1.11.5.linux-amd64.tar.gz
```

#### vim-go commands
vim-go其實算是一個懶人包的plugin, 它集合了各種golang的小工具, 所以第一次使用前要先安裝這些小工具.
`:GoInstallBinaries`會從網路下載小工具的source code至GOPATH, 並將其編譯成binary供之後使用.

---

### Chapter 1 Tutorial
本書作者之一的Kernighan也是The C Programming Language的作者, 所以第一章的風格就如同K&R C一樣,
快速將golang介紹一遍, 讓人可以很快上手.

#### [1.1] Hello, World
golang程式碼的架構由上至下可以分成三部份:
- package declarations
- import declarations
- other declarations(functions, variables, consts, types...)

屬於同一個package的source code都放在同一個資料夾. main是一個特殊的package name,
表示此package會組成一個獨立的執行檔, 而不是函式庫.

本節提到的一些go tool使用, 其vim-go的對照如下:
- go run    => `:GoRun`
- gofmt     => `:GoFmt`
- goimports => `:GoImports`

#### [1.2] Command-Line Arguments
slice s的表達式: s[m:n], 0 <= m <= n <= len(s), 其中m和n都可以省略, 省略的話m = 0, n = len(s).

和C/C++不一樣, golang只有i++, i--, 沒有++i, --i.

golang只有一種loop construct *for*, 其語法如下, 每一部分都可以省略:
```go
for initialization; condition; post {
    ...
}

// the while equivalent
for condition {
    ...
}
```
當然golang也支援range based的for loop:
```go
// i is index, v is os.Args[i]
for i, v := range os.Args[1:] {
    ...
}
```
`_`在golang稱為blank identifier, 通常當做temp variable使用, 因為golang不允許unused variables.

#### [1.3] Finding Duplicate Lines
golang的else必須緊接在`}`之後, 不可以成為一行的開頭.
```go
if condition {
    ...
} else {
    ...
}
```
---

### Chapter 2 Program Structure

#### [2.1] Names
golang的命名格式是camel case(ex. parseRequestLine), 縮寫的名詞則是全部大寫或全部小寫(ex. escapeHTML).

#### [2.3]Variable
1. 變數的宣告方式如下:
```go
var name type = expression
```
- 可以省略type, 其type由expression決定
- 可以省略expression, 其值為此type的0值, 所以golang沒有uninitialized variable的問題.
  interfaces和reference type(slice, pointer, map, channel, function)的0值為nil
2. 如果變數有初始值且不是package level變數, 可以用以下方式宣告並賦值
name := expression
要注意的是, 此種宣告方式不代表會宣告所有的變數, 如果其中變數之前有宣告過
, 那等同於assignment, 但最少要有一個新變數宣告才不會有compile error
    ```go
    in, err := os.Open(inFile)
    out, err := os.Open(outFile)
    ```
3. Pointer型態的type宣告是\*type(從左往右的方式去指定pointer, array和type
, 剛好可以用英文去描述)
4. 在function中return local變數的位址是合法的, 以下二個例子作用相同
   ```go
   func newInt() *int {
       return new(int)
   }
   func newInt() *int {
       var dummy int
       return &dummy
   }
   ```
5. function中變數的來源是heap或stack, 由escape from function與否決定. 使用new
不代表變數就來自heap, 而是看其在離開function後, 是否仍有方式可以被reference到. 一般來說,
escape variable會有額外的memory開銷

#### [2.4] Assignments
tuple assignment會先evaluate右邊的expression再賦值給左邊的expression.
```go
// swap values of x, y easily
x, y = y, x
```

#### [2.5] Type Declarations
語法是`type name underlying-type`, 支援的運算元由underlying type決定,
可以與underlying type的運算子做運算, 但是不同type即使underlying type相同也不可做運算.

T(x)表示將x轉型成type T, 條件是x和T具有相同的underlying type

#### [2.6] Packages and Files
import path代表了package存放的資料夾位置, *import "gopl.io/ch2/tempconv"*表示package tempconv
存放在GOPATH/src/gopl.io/ch2/tempconv.

在package裡, 首字大寫的names是exported的, 可以被其它外部的package引用.

golang不允許unused package被import, 因此可以利用`:GoImports`去自動管理import packages的增減.

init function只能用來做package initialization, 無法被呼叫或引用.
```go
// package initialization for package level variables
func init() {
    ...
}
```

gopl.io/ch2/popcount中的init function所做的事是預先計算0~255的population count, 原理是N和1
先做bit and得到LSB的popcount, 再將N向右shift 1個bit, 剩下的popcount剛好是之前計算過的N/2的popcount.

---

### Chapter 3 Basic Data Types

#### [3.1] Integers
- int和uint實際的data size是32 bits or 64bits視compiler/platform決定.
- rune是int32的alias, byte是uint8的alias
- ^也可以當做unary operator使用, `^x`其效果等同於C/C++的`~x`(bitwise NOT).
  &^則是bit clear operator, `x &^ y`其效果等同於C/C++的`x & ~y`.
- 54頁的下面解釋了為什麼int會比uint常使用的原因, 即使資料的值沒有負數
- golang不允許implicit conversion, 所以binary operator的二邊不同type會無法compile.
- fmt.Printf的format specifier, #和[1]的特殊意義.
- rune literal是以'(單引號)包住的character

#### [3.2] Floating-Point Numbers
- 因為精度的關係, 書上建議使用float64而不是float32.
- 任何和NaN做比較的結果都是false(包括NaN和自己互相比較)
- 範例的數學推導如下:
  - 2D => 3D: (0~cells)對應到(-xyrange/2, xyrange/2), 因此i / cells = (x + xyrange / 2) / xyrange,
    所以x = xyrange * (i / cells - 0.5)
  - 3D => 2D: 假設x-axis和cx-axis有angle度夾角, y-axis和cx-axis的夾角亦同, 投影後的原點在畫布中央,
    xyrange對應到width / 2(也就是xyscale = width / (2 * xyrange)), 所以x = width / 2 + (x * cos(angle) - y * cos(angle)) * xyscale

---

### Chapter 4 Composite Types

#### [4.1] Arrays
golang的array可以使用array literal進行初始化
```go
var p [3]int = [3]int{1, 2, 3}
// ... means the size of array determined by initializer list
q := [...]int{1, 2, 3, 4}
// array of 100 ints, the value of each element is 0 except r[99] = -1
r := [...]int{99: -1}
```
如果二個array的size和element type相同, 可以使用==和!=做element-wise比較.

golang的array和C/C++不同, 當做function parameter時不是reference type.

#### [4.2] Slices
slice可以想成是具了三個成員的struct, *data*指向underlying array的element,
*len*則是slice的長度, *cap*則是slice可以延伸的最大長度(受限於underlying array的大小).
因此, slice算是underlying array的一個view.

利用slice opertor建立slice: `s[i:j], 0<=i<=j<=cap(s)`, s可以是array, pointer to array或是slice.

slice不同於array, 不支援slice間的==和!=運算, 和nil比較除外. len和cap為0的slice不一定是nil slice.
```go
var s []int // nil slice
s = []int{} // slice literal, non-nil slice
```
利用make建立unamed array來得到slice
```go
make([]T, len)
make([]T, len, cap) // equivalent to make([]T, cap)[:len]
```
4.2.1詳細說明了append的簡化實作, slice會因為element的增加而導致underlying array重新reallocation的可能.

#### [4.3] Maps
- map[K]V, K和V都是type, K必須是comparible type, 所以slice不能當做key. 浮點數即使是comparible,
但也不是key的好選擇. 97頁有提到把non-comparible type轉成string後當做key來workaround這限制.
- 即使map中不存在key value, 也可以存取此mapping的value, 得到的是value type的0值. 有時,
會需要知道map中是否存在key value, 可以用以下方式的ok變數取得此資訊:
```go
var ages map[string]int
// ok == true means the key exists
age, ok := ages["bob"]
```
- map的element無法得到address值, 因為map新增elements會造成rehashing而改變既有elements的儲存位置.
- 從map移除key: `delete(map, key)`

#### [4.4] Structs
- struct的宣告通常和type一起建立named type:
```go
// named type Point, X and Y are fields of struct
type Point struct {
    X, Y int
}
```
- 變數是struct或pointer to struct, 都可以使用`.`存取struct的fields.
- 和package類似, fields名字首字大寫的是exported fields.
- struct的fields如果都是comparible types, 那麼此struct就支援==, !=(比較方式是field-wise).
- 利用anonymous fields來embedding其它struct的好處是可以直接存取embedding的fields, 也不受embedding struct
  type是否有exported的限制. 由於使用struct type當做anonymous field, 同一種struct不能重複anonymous embedding.

```go
type Circle struct {
    Point
    Radius int
}
type Wheel struct {
    Circle
    Spokes int
}

var w Wheel
w.X = 8 // equivalent to w.Circle.Point.X = 8

// if Circle and Point are not exported name,
// shorthand form is still valid.
// but not w.circle.point.X = 8
```

#### [4.5] JSON
golang的struct可以很容易的和JSON做轉換, 只有exported fields才會輸出至JSON, field tags則可以控制輸出至JSON的name

---

### Chapter 10 Packages and the Go Tool

#### [10.4] Import Declarations
multiple imports通常都以下面方式呈現:
```go
import (
    "fmt"
    "os"
)
//
// which is equivalent to:
// import "fmt"
// import "os"
//
```
renaming import可以避免不同import path但是同package name造成的conflicts
```go
import (
    "crypto/rand"
    mrand "math/rand"
)
```

#### [10.7] The Go Tool
go env會列出golang相關的環境變數, 重要的環境變數有GOPATH(workspace目錄), GOROOT(golang安裝目錄),
GOOS和GOARCH(cross compiling會用到).

- `go run`: 執行完後什麼東西都不保留
- `go build`: 只保留執行檔, 但捨棄依賴的packages產出
- `go install`: 相較於`go build`會保留packages在$GOPATH/pkg

`go build`的package參數可以使用import path或是relative path, 但是使用relative path時前面一定要有`.`或`..`.

internal package是import path中有internal的路徑名稱, 只能被某些packages import.
ex: *net/http/internal/chunked*能被*net/http*或是*net/http/httputil* import.
